#! /usr/bin/env python
# -*- coding: utf-8 -*-

import numpy

# Количество систем обслуживания
L = 6

# Число приборов в системе
kappa = 1

# Маршрутная матрица
TETA = numpy.array([[0, 0.2, 0, 0.8, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 0.3, 0, 0.7, 0, 0],
                    [0, 0, 0.3, 0, 0, 0.2, 0.5],
                    [0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0]])

# Вектор интенсивностей обслуживания
mu = numpy.array( [4, 1, 2, 5, 3, 2, 3] )

# Интенсивность потока из источника
lambda0 = 0.8

# Создаем единичную матрицу, необходимую для решения системы
I = numpy.eye(L + 1, dtype=float)

A = TETA.transpose() - I

# Заполняем последнюю строчку матрицы A нулями
A[L, :] = numpy.ones(L + 1, dtype=float)

# Создаем матрицу-столбец B системы, состоящую из нулей с единицей в нижней строке
B = numpy.zeros(L + 1, dtype=float)
B[L] = 1

# Решаем систему, получаем распределение вероятностей поступления требований в системы
omega = numpy.linalg.solve(A, B)

# Создаем матрицу интенсивностей потоков
lambdai = numpy.zeros(L + 1)
lambdai[0] = lambda0

# Рассчет интенсивностей потоков
for i in range(1, L):
    lambdai[i] = ( omega[i] / omega[0] ) * lambdai[0]

# Вывод интенсивностей потоков
print(lambdai)

# Коэффициент использования обслуживающих приборов системы (коэффициент загрузки).
psi = lambdai / mu

# Рассчет м.о. числа требований в системе
Mn = psi / ( 1 - psi )
print(Mn)

#  Рассчет м.о. длительности пребывания требований в системе
Mu = 1 / ( mu - lambdai )
print(Mu)

